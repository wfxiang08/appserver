package backends

import (
	"os"
	"os/exec"
	"strings"
	"sync"
	"time"
	log "git.chunyu.me/golang/cyutils/utils/rolling_log"

	"github.com/howeyc/fsnotify"
	"io/ioutil"
	"path"
	"regexp"
)

var (
	cmd          *exec.Cmd
	state sync.Mutex
	eventTime = make(map[string]int64)
	scheduleTime time.Time

	appDirs = make(map[string]bool)
)

func addWatchPath(appsRootDir string, watcher *fsnotify.Watcher) {
	// 首先删除所有的被watch的文件
	// 删除
	for key, _ := range appDirs {
		watcher.RemoveWatch(key)
	}
	appDirs = make(map[string]bool)


	// 扫描目录
	dir, err := ioutil.ReadDir(appsRootDir)
	if err != nil {
		log.Errorf("[ERRO] Fail to create new Watcher[ %s ]\n", err)
		os.Exit(2)
	}

	log.Infof("[INFO] Initializing watcher...\n")
	// 遍历所有的目录
	for _, fi := range dir {
		if !fi.IsDir() {
			// 忽略目录
			continue
		}
		appDir := path.Join(appsRootDir, fi.Name())
		log.Infof("[TRAC] Directory( %s )\n", appDir)
		appDirs[appDir] = true
		err = watcher.Watch(appDir)
		if err != nil {
			log.Errorf("[ERRO] Fail to watch directory[ %s ]\n", err)
			os.Exit(2)
		}

	}
}

// 来自beego
func NewWatcher(appsRootDir string, autoScan func()) chan bool {
	watcher, err := fsnotify.NewWatcher()
	if err != nil {
		log.Errorf("[ERRO] Fail to create new Watcher[ %s ]\n", err)
		os.Exit(2)
	}

	watcher.Watch(appsRootDir)
	addWatchPath(appsRootDir, watcher)

	done := make(chan bool)
	go func() {
		for {
			select {
			case <-done:
				log.Info("Done")
			case e := <-watcher.Event:
			// TODO: 自动扫描
			// Skip ignored files
				if shouldIgnoreFile(e.Name) {
					continue
				}
				if !checkIfWatchExt(e.Name) {
					continue
				}

				isbuild := true
				mt := getFileModTime(e.Name)
				if t := eventTime[e.Name]; mt == t {
					ColorLog("[SKIP] # %s #\n", e.String())
					isbuild = false
				}

				eventTime[e.Name] = mt

			// 如果已经Schedule了，则跳过
				if isbuild && scheduleTime.Unix() < mt {
					ColorLog("[EVEN] %s\n", e)
					go func() {
						// Wait 1s before autobuild util there is no file change.
						scheduleTime = time.Now().Add(10 * time.Second)
						for {
							time.Sleep(scheduleTime.Sub(time.Now()))
							if time.Now().After(scheduleTime) {
								break
							}
							return
						}

						// 重新watch
						addWatchPath(appsRootDir, watcher)

						// 开启扫描模式
						autoScan()
					}()
				}

			case err := <-watcher.Error:
				log.Warnf("[WARN] %s\n", err.Error()) // No need to exit here
			}
		}
	}()

	return done
}

// getFileModTime retuens unix timestamp of `os.File.ModTime` by given path.
func getFileModTime(path string) int64 {
	path = strings.Replace(path, "\\", "/", -1)
	f, err := os.Open(path)
	if err != nil {
		log.Errorf("[ERRO] Fail to open file[ %s ]\n", err)
		return time.Now().Unix()
	}
	defer f.Close()

	fi, err := f.Stat()
	if err != nil {
		log.Errorf("[ERRO] Fail to get file information[ %s ]\n", err)
		return time.Now().Unix()
	}

	return fi.ModTime().Unix()
}


// checkTMPFile returns true if the event was for TMP files.
func checkTMPFile(name string) bool {
	if strings.HasSuffix(strings.ToLower(name), ".tmp") {
		return true
	}
	return false
}


// Should ignore filenames generated by
// Emacs, Vim or SublimeText
func shouldIgnoreFile(filename string) bool {
	for _, regex := range ignoredFilesRegExps {
		r, err := regexp.Compile(regex)
		if err != nil {
			panic("Could not compile the regex: " + regex)
		}
		if r.MatchString(filename) {
			return true
		} else {
			continue
		}
	}
	return false
}

var watchExts = []string{".ipa", ".apk", ".plist", ".png", "mobileprovision", ".json"}
var ignoredFilesRegExps = []string{
	`(\w+)___`,
	`.#(\w+).go`,
	`.(\w+).go.swp`,
	`(\w+).go~`,
	`(\w+).tmp`,
}

// checkIfWatchExt returns true if the name HasSuffix <watch_ext>.
func checkIfWatchExt(name string) bool {
	for _, s := range watchExts {
		if strings.HasSuffix(name, s) {
			return true
		}
	}
	return false
}
